<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>p10_customer_segmentation.utf8</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/simplex.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<!-- Google Tag Manager -->

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NFJ7QKG');</script>

<!-- End Google Tag Manager -->

<!-- Script hiding navbar when scrolling down -->

<script>
  var didScroll;
  var lastScrollTop = 0;
  var delta = 1;
  var navbarHeight = $('[role="navigation"]').outerHeight();

  $(window).scroll(function(event) {
    didScroll = true;
  });

  setInterval(function() {
    if (didScroll) {
      hasScrolled();
      didScroll = false;
    }
  }, 250);

  function hasScrolled() {
    var st = $(this).scrollTop();

    if (Math.abs(lastScrollTop - st) <= delta)
      return;

    if (st > lastScrollTop && st > navbarHeight) {
      // Scroll Down
      $('[role="navigation"]').addClass('navbar-scroll-down');
    } else {
      // Scroll Up
      if (st + $(window).height() < $(document).height()) {
        $('[role="navigation"]').removeClass('navbar-scroll-down');
      }
    }

    lastScrollTop = st;
  }
</script>

<!-- End of script hiding navbar when scrolling down -->

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 41px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h2 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h3 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h4 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h5 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h6 {
  padding-top: 46px;
  margin-top: -46px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Analytics@Sauder</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="contribute.html">Contribute</a>
</li>
<li>
  <a href="https://blogs.ubc.ca/businessanalytics">Blog</a>
</li>
<li>
  <a href="projects.html">Projects</a>
</li>
<li>
  <a href="resources.html">Resource</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<!-- Google Tag Manager (noscript) -->

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NFJ7QKG"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

<!-- End Google Tag Manager (noscript) -->

<div class="fluid-row" id="header">




</div>


<div id="customer-segmentation" class="section level2">
<h2>Customer Segmentation</h2>
<div id="author-kemjika-ananaba" class="section level4">
<h4>Author: Kemjika Ananaba</h4>
<p>In this Project, we will focus on combining RFM (Recency, Frequency, and Monetary value) analysis with clustering analysis to to identify different market segments. We encourage you to create your own Jupytor Notebook and follow along. You can also download this Notebook together with any accompanying data in the <a href="https://github.com/Master-of-Business-Analytics/Notebooks_and_Data">Notebooks and Data</a> GitHub Repository. Alternatively, if you do not have Python or Jupyter Notebook installed yet, you may experiment with a virtual Notebook by launching Binder or Syzygy below (learn more about these two tools in the <a href="https://analytics-at-sauder.github.io/resource.html">Resource</a> tab).</p>
<p><a href="https://ubc.syzygy.ca/jupyter/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2FAnalytics-at-Sauder%2FProject_10_Customer_Segmentation&urlpath=tree%2FProject_10_Customer_Segmentation%2Fp10_customer_segmentation.ipynb&branch=master" target="_blank" class="button">Launch Syzygy (UBC)</a></p>
<p><a href="https://pims.syzygy.ca/jupyter/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2FAnalytics-at-Sauder%2FProject_10_Customer_Segmentation&urlpath=tree%2FProject_10_Customer_Segmentation%2Fp10_customer_segmentation.ipynb&branch=master" target="_blank" class="button">Launch Syzygy (Google)</a></p>
<p><a href="https://mybinder.org/v2/gh/Analytics-at-Sauder/Project_10_Customer_Segmentation/master?filepath=p10_customer_segmentation.ipynb" target="_blank" class="button">Launch Binder</a></p>
</div>
</div>
<div id="business-problem" class="section level2">
<h2>Business Problem</h2>
<hr />
<p>Customer analytics are crucial in running a successful business. Sales and marketing resources are finite and expensive; therefore, it is important to answer these questions when developing a marketing strategy:</p>
<ul>
<li>Who are our most/least valuable customers?</li>
<li>How can we acquire new customers that resemble our most valuable customers?</li>
</ul>
<p>The Recency, Frequency, and Monetary value strategy has been around the industry for a while and provides a simple but effective method of segmenting customers. Our Project on <a href="https://master-of-business-analytics.github.io/Website/RFM_Analysis.html">RFM analysis</a> provides a basic model that allows businesses to segment their customers according to three criteria, based on an existing customer’s transaction history: the recency of a customer’s last purchase, the frequency of a customer’s purchases, and the total amount spent (which is referred to as “monetary”).</p>
<p>An RFM model can also be used in conjunction with certain predictive models to gain even further insight into customer behaviour. In this Project, we analyze the k-means clustering algorithm to witness how this technique can enhance the results of an RFM analysis.</p>
<p>Here is a high-level flow of the analysis:</p>
<ul>
<li>We first calculate the R, F, and M parameters,</li>
<li>Then we apply the k-means clustering algorithm on the three parameters to group similar customers.</li>
</ul>
<p>K-means clustering is a popular approach for classification because of its simplicity in implementation and because it has been widely used in the practice of market segmentation. The number of clusters can be determined by using the elbow method.</p>
</div>
<div id="dataset" class="section level2">
<h2>Dataset</h2>
<p>There are eight variables in the dataset:</p>
<ol style="list-style-type: decimal">
<li>InvoiceNo: invoice number, a 6-digit integral number uniquely assigned to each transaction.</li>
<li>StockCode: product code, a 5-digit integral number uniquely assigned to each distinct product.</li>
<li>Description: product name.</li>
<li>Quantity: quantities of each product (item) per transaction.</li>
<li>InvoiceDate: invoice date and time, a numeric value of the date and time when each transaction was generated.</li>
<li>UnitPrice: unit price, a numeric value of the product price, per unit, in sterling.</li>
<li>CustomerID: customer number, a 5-digit integral number uniquely assigned to each customer.</li>
<li>Country</li>
</ol>
<pre class="python"><code>import pandas as pd
import numpy as np
import seaborn as sns
from datetime import timedelta
import matplotlib.pyplot as plt
import warnings
from sklearn.cluster import KMeans
#ignore warnings
warnings.filterwarnings(&#39;ignore&#39;)

pd.set_option(&quot;display.max_columns&quot;,None);
pd.set_option(&quot;display.max_rows&quot;,None);

#load data
url = &#39;https://raw.githubusercontent.com/Master-of-Business-Analytics/Project_06_RFM_Analysis/master/data_1.csv&#39;
df = pd.read_csv(url, error_bad_lines=False,encoding= &#39;unicode_escape&#39;)</code></pre>
<pre class="python"><code>#summary of dataset
df.head(5)</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
InvoiceNo
</th>
<th>
StockCode
</th>
<th>
Description
</th>
<th>
Quantity
</th>
<th>
InvoiceDate
</th>
<th>
UnitPrice
</th>
<th>
CustomerID
</th>
<th>
Country
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
540558
</td>
<td>
21258
</td>
<td>
?
</td>
<td>
-29
</td>
<td>
2011-01-10 10:04:00
</td>
<td>
0.00
</td>
<td>
NaN
</td>
<td>
United Kingdom
</td>
</tr>
<tr>
<th>
1
</th>
<td>
540560
</td>
<td>
21589
</td>
<td>
NaN
</td>
<td>
-14
</td>
<td>
2011-01-10 10:08:00
</td>
<td>
0.00
</td>
<td>
NaN
</td>
<td>
United Kingdom
</td>
</tr>
<tr>
<th>
2
</th>
<td>
540561
</td>
<td>
22343
</td>
<td>
PARTY PIZZA DISH RED RETROSPOT
</td>
<td>
24
</td>
<td>
2011-01-10 10:32:00
</td>
<td>
0.21
</td>
<td>
13004.0
</td>
<td>
United Kingdom
</td>
</tr>
<tr>
<th>
3
</th>
<td>
540561
</td>
<td>
22344
</td>
<td>
PARTY PIZZA DISH PINK POLKADOT
</td>
<td>
24
</td>
<td>
2011-01-10 10:32:00
</td>
<td>
0.21
</td>
<td>
13004.0
</td>
<td>
United Kingdom
</td>
</tr>
<tr>
<th>
4
</th>
<td>
540561
</td>
<td>
47504H
</td>
<td>
ENGLISH ROSE SPIRIT LEVEL
</td>
<td>
24
</td>
<td>
2011-01-10 10:32:00
</td>
<td>
0.85
</td>
<td>
13004.0
</td>
<td>
United Kingdom
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="data-cleaning" class="section level2">
<h2>Data Cleaning</h2>
<p>The dataset seems to be relatively clean at first glance, but it is actually riddled with errors. There are several positive/negative offsetting entries throughout the dataset, in addition to other apparent errors, such as customers with negative transactions. More information on data cleaning can be found in our <a href="https://master-of-business-analytics.github.io/Website/Data_Cleaning.html">Data Cleaning Project</a>.</p>
<p>The first step in cleaning the dataset is to check if there are any missing values and where the missing values are located.</p>
<pre class="python"><code>
#Visualize the number of null values in the dataframe for each column
df.isnull().sum().plot(kind=&#39;bar&#39;)</code></pre>
<p><img src="rfm_1.png" /></p>
<p>The bar chart above shows that the NaN values are located in the Description column and the CustomerID column. The purpose of this Project is to segment the current customers of a business; therefore, transactions without a valid CustomerID do not provide any value and are dropped from the data frame.</p>
<pre class="python"><code>#Eliminating rows with NA
df=df.dropna(subset=[&#39;CustomerID&#39;])

#NA status across columns
df.isnull().sum()</code></pre>
<pre><code>

    InvoiceNo      0
    StockCode      0
    Description    0
    Quantity       0
    InvoiceDate    0
    UnitPrice      0
    CustomerID     0
    Country        0
    dtype: int64
</code></pre>
<pre class="python"><code>df.describe()</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Quantity
</th>
<th>
UnitPrice
</th>
<th>
CustomerID
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
count
</th>
<td>
60426.000000
</td>
<td>
60426.000000
</td>
<td>
60426.000000
</td>
</tr>
<tr>
<th>
mean
</th>
<td>
11.121868
</td>
<td>
3.134313
</td>
<td>
15500.429368
</td>
</tr>
<tr>
<th>
std
</th>
<td>
429.524058
</td>
<td>
6.663764
</td>
<td>
1597.854971
</td>
</tr>
<tr>
<th>
min
</th>
<td>
-74215.000000
</td>
<td>
0.000000
</td>
<td>
12346.000000
</td>
</tr>
<tr>
<th>
25%
</th>
<td>
2.000000
</td>
<td>
1.250000
</td>
<td>
14180.000000
</td>
</tr>
<tr>
<th>
50%
</th>
<td>
4.000000
</td>
<td>
1.950000
</td>
<td>
15408.000000
</td>
</tr>
<tr>
<th>
75%
</th>
<td>
12.000000
</td>
<td>
3.750000
</td>
<td>
16931.000000
</td>
</tr>
<tr>
<th>
max
</th>
<td>
74215.000000
</td>
<td>
856.480000
</td>
<td>
18283.000000
</td>
</tr>
</tbody>
</table>
</div>
<p>The summary table illustrates that very large negative values under Quantity. Further analysis shows that the minimum and maximum values have the same absolute values (74,215). This could simply be a product of a mistake in data entry. There are two ways data input errors are usually corrected: - entering a value with the opposite sign to cancel out the previous mistake (so the minimum value will no longer be -74,215, but instead be +74,215, which is the maximum value), or - entering the difference between the actual transaction and the previous entry.</p>
<p>The first instance is corrected by: 1. confirming that both transactions are for the same customer (if so, drop the duplicated row), and 2. repeating the previous step until the the minimum and maximum Quantity values do not have the same absolute values.</p>
<pre class="python"><code>#First of all we select relevant columns
df2 = df[[&#39;InvoiceDate&#39;,&quot;CustomerID&quot;,&#39;StockCode&#39;,&#39;UnitPrice&#39;,&#39;Quantity&#39;]]
#snapshoot of new dataframe
df2.head()</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
InvoiceDate
</th>
<th>
CustomerID
</th>
<th>
StockCode
</th>
<th>
UnitPrice
</th>
<th>
Quantity
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
2
</th>
<td>
2011-01-10 10:32:00
</td>
<td>
13004.0
</td>
<td>
22343
</td>
<td>
0.21
</td>
<td>
24
</td>
</tr>
<tr>
<th>
3
</th>
<td>
2011-01-10 10:32:00
</td>
<td>
13004.0
</td>
<td>
22344
</td>
<td>
0.21
</td>
<td>
24
</td>
</tr>
<tr>
<th>
4
</th>
<td>
2011-01-10 10:32:00
</td>
<td>
13004.0
</td>
<td>
47504H
</td>
<td>
0.85
</td>
<td>
24
</td>
</tr>
<tr>
<th>
5
</th>
<td>
2011-01-10 10:32:00
</td>
<td>
13004.0
</td>
<td>
84509G
</td>
<td>
1.25
</td>
<td>
12
</td>
</tr>
<tr>
<th>
6
</th>
<td>
2011-01-10 10:32:00
</td>
<td>
13004.0
</td>
<td>
22720
</td>
<td>
4.95
</td>
<td>
3
</td>
</tr>
</tbody>
</table>
</div>
<pre class="python"><code>#row data of maximum and minimum data
df2.loc[[df2[&#39;Quantity&#39;].idxmax(),df[&#39;Quantity&#39;].idxmin()]]</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
InvoiceDate
</th>
<th>
CustomerID
</th>
<th>
StockCode
</th>
<th>
UnitPrice
</th>
<th>
Quantity
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
10537
</th>
<td>
2011-01-18 10:01:00
</td>
<td>
12346.0
</td>
<td>
23166
</td>
<td>
1.04
</td>
<td>
74215
</td>
</tr>
<tr>
<th>
10542
</th>
<td>
2011-01-18 10:17:00
</td>
<td>
12346.0
</td>
<td>
23166
</td>
<td>
1.04
</td>
<td>
-74215
</td>
</tr>
</tbody>
</table>
</div>
<pre class="python"><code>#remove containing row minimum and maximum quantity as it is basically a duplicate
df2.drop(index=[df2[&#39;Quantity&#39;].idxmax(), df2[&#39;Quantity&#39;].idxmin()], inplace=True)

#chack minimum and maximum quantity 
df2.describe()</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
CustomerID
</th>
<th>
UnitPrice
</th>
<th>
Quantity
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
count
</th>
<td>
60424.000000
</td>
<td>
60424.000000
</td>
<td>
60424.000000
</td>
</tr>
<tr>
<th>
mean
</th>
<td>
15500.533778
</td>
<td>
3.134383
</td>
<td>
11.122236
</td>
</tr>
<tr>
<th>
std
</th>
<td>
1597.778348
</td>
<td>
6.663863
</td>
<td>
46.762862
</td>
</tr>
<tr>
<th>
min
</th>
<td>
12747.000000
</td>
<td>
0.000000
</td>
<td>
-720.000000
</td>
</tr>
<tr>
<th>
25%
</th>
<td>
14180.000000
</td>
<td>
1.250000
</td>
<td>
2.000000
</td>
</tr>
<tr>
<th>
50%
</th>
<td>
15408.000000
</td>
<td>
1.950000
</td>
<td>
4.000000
</td>
</tr>
<tr>
<th>
75%
</th>
<td>
16931.000000
</td>
<td>
3.750000
</td>
<td>
12.000000
</td>
</tr>
<tr>
<th>
max
</th>
<td>
18283.000000
</td>
<td>
856.480000
</td>
<td>
3906.000000
</td>
</tr>
</tbody>
</table>
</div>
<p><b> Note:</b> the minimum Quantity and maximum Quantity no longer have the same absolute values. However, if they continued to share the same absolute value, then the above step is repeated until they are no longer the same.</p>
<p>The next step is to convert the InvoiceDate column to a date format, and then calculate the total sales column, “Totalsum” (calculated as the Quantity multiplied by the UnitPrice for each transaction).</p>
<pre class="python"><code># Convert InvoiceDate from object to datetime format
df2[&#39;InvoiceDate&#39;] = pd.to_datetime(df2[&#39;InvoiceDate&#39;])

#remove minutes and seconds from date
df2[&#39;InvoiceDate&#39;] = df2.InvoiceDate.dt.date

                        
#creating a total sales column
df2[&quot;Totalsum&quot;] = df2[&#39;Quantity&#39;] * df2[&#39;UnitPrice&#39;]

df2.head(5)</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
InvoiceDate
</th>
<th>
CustomerID
</th>
<th>
StockCode
</th>
<th>
UnitPrice
</th>
<th>
Quantity
</th>
<th>
Totalsum
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
2
</th>
<td>
2011-01-10
</td>
<td>
13004.0
</td>
<td>
22343
</td>
<td>
0.21
</td>
<td>
24
</td>
<td>
5.04
</td>
</tr>
<tr>
<th>
3
</th>
<td>
2011-01-10
</td>
<td>
13004.0
</td>
<td>
22344
</td>
<td>
0.21
</td>
<td>
24
</td>
<td>
5.04
</td>
</tr>
<tr>
<th>
4
</th>
<td>
2011-01-10
</td>
<td>
13004.0
</td>
<td>
47504H
</td>
<td>
0.85
</td>
<td>
24
</td>
<td>
20.40
</td>
</tr>
<tr>
<th>
5
</th>
<td>
2011-01-10
</td>
<td>
13004.0
</td>
<td>
84509G
</td>
<td>
1.25
</td>
<td>
12
</td>
<td>
15.00
</td>
</tr>
<tr>
<th>
6
</th>
<td>
2011-01-10
</td>
<td>
13004.0
</td>
<td>
22720
</td>
<td>
4.95
</td>
<td>
3
</td>
<td>
14.85
</td>
</tr>
</tbody>
</table>
</div>
<pre class="python"><code># information about the data set
print(&#39;{:,} rows; {:,} columns&#39;
      .format(df2.shape[0], df2.shape[1]))
print(&#39;{:,} transactions don\&#39;t have a customer id&#39;
      .format(df2[df2.CustomerID.isnull()].shape[0]))
print(&#39;Transactions timeframe from {} to {}&#39;.format(df2[&#39;InvoiceDate&#39;].min(),
                                    df2[&#39;InvoiceDate&#39;].max()))</code></pre>
<pre><code>    60,424 rows; 6 columns
    0 transactions don&#39;t have a customer id
    Transactions timeframe from 2011-01-04 to 2011-03-30</code></pre>
</div>
<div id="rfm-model" class="section level2">
<h2>RFM Model</h2>
<p>The RFM model describes the historical purchase behaviour of a company’s current customers using three criteria:</p>
<ul>
<li>When did the customer make their last purchase?</li>
<li>How often does the customer make a purchase?</li>
<li>How much money does the customer spend?</li>
</ul>
<p>The general assumption with the RFM model is that customers who purchase in shorter time intervals, in greater volumes, and at higher prices are more like to respond positively to future engagement and product offers. To identify who these responsive customers are, the customer records are grouped by the recency of the purchases, the frequency by the quantities, and the monetary value of the purchases.</p>
<pre class="python"><code># create a table that aggregates the transactions by customer id to 
# obtain recency score, frequency of purchase and monetary value


#group customers by their most recent purchase
snapshot_date = df2[&#39;InvoiceDate&#39;].max() + timedelta(days=1)  

#creat recency table by comparing most recent transaction to snapshot date by customer ID
rec_df = snapshot_date-df2.groupby(&quot;CustomerID&quot;).agg({&quot;InvoiceDate&quot;:max}) 

#renaming column names
rec_df.rename(columns={&quot;InvoiceDate&quot;: &quot;Recency&quot;}, inplace=True)#rename column
rec_df=rec_df[&quot;Recency&quot;].apply(lambda x: x.days) #extracting number of days only

#creating frequency and monetary table by grouping number of purchases and total money spent by customer ID
fmTable = df2.groupby(&#39;CustomerID&#39;).agg({&#39;CustomerID&#39;: lambda x: len(x),               # Frequency
                                        &#39;Totalsum&#39;: lambda x: x.sum()})          # Monetary Value
#renaming column names
fmTable.rename(columns={
                         &#39;CustomerID&#39;: &#39;Frequency&#39;, 
                         &#39;Totalsum&#39;: &#39;Monetary&#39;}, inplace=True)

#combining the fm table and the recency table

rfm_df = pd.concat([rec_df,fmTable],axis=1)
rfm_df.head()
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Recency
</th>
<th>
Frequency
</th>
<th>
Monetary
</th>
</tr>
<tr>
<th>
CustomerID
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
12747.0
</th>
<td>
30
</td>
<td>
17.0
</td>
<td>
613.82
</td>
</tr>
<tr>
<th>
12748.0
</th>
<td>
6
</td>
<td>
337.0
</td>
<td>
1820.35
</td>
</tr>
<tr>
<th>
12820.0
</th>
<td>
73
</td>
<td>
11.0
</td>
<td>
170.46
</td>
</tr>
<tr>
<th>
12823.0
</th>
<td>
1
</td>
<td>
3.0
</td>
<td>
994.50
</td>
</tr>
<tr>
<th>
12826.0
</th>
<td>
63
</td>
<td>
40.0
</td>
<td>
542.10
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="cluster-analysis" class="section level2">
<h2>Cluster Analysis</h2>
<p>Clustering is the process of dividing the entire data into groups (also known as clusters) based on the patterns in the data. The k-means clustering technique is an algorithm that tries to minimize the distance of the points in a cluster to their centroid. There are two steps in cluster analysis:</p>
<ol style="list-style-type: decimal">
<li><p>finding the optimal number of clusters: the number of clusters, a value which decreases in inertia value and becomes constant, can be chosen as the right number of clusters for our data;</p></li>
<li><p>fit to the k-means model.</p></li>
</ol>
<p>Looking at the RFM data table above, we observe a lot of variation in the magnitude of the data. Since k-means is a distance-based algorithm, this range in magnitude can be problematic; therefore, all the variables are standardized to the same magnitude using the scaler function.</p>
<pre class="python"><code>

# --Calculate R and F groups--
rfm_df1= rfm_df.copy()

# Create labels for Recency and Frequency and MonetaryValue
r_labels = range(4, 0, -1) #[4,3,2,1] 
f_labels = range(1, 5)   #[1,2,3,4]
#m_labels = range(1, 5)

# Assign these labels to 4 equal percentile groups 
r_groups = pd.qcut(rfm_df1[&#39;Recency&#39;], q=4, labels=r_labels)
# Assign these labels to1111 4 equal percentile groups 
f_groups = pd.qcut(rfm_df1[&#39;Frequency&#39;], q=4, labels=f_labels)

# standardizing the data
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
data_scaled = scaler.fit_transform(rfm_df)

# fitting multiple k-means algorithms and storing the values in an empty list
SSE = []
for cluster in range(1,20):
    kmeans = KMeans(n_jobs = -1, n_clusters = cluster, init=&#39;k-means++&#39;)
    kmeans.fit(data_scaled)
    SSE.append(kmeans.inertia_)

# converting the results into a dataframe and plotting them
frame = pd.DataFrame({&#39;Cluster&#39;:range(1,20), &#39;SSE&#39;:SSE})
plt.figure(figsize=(12,6))
plt.plot(frame[&#39;Cluster&#39;], frame[&#39;SSE&#39;], marker=&#39;o&#39;)
plt.xlabel(&#39;Number of Clusters&#39;)
plt.ylabel(&#39;Inertia&#39;)
plt.title(&#39;Elbow Curve&#39;)</code></pre>
<p><img src="rfm_2.png" /></p>
<pre class="python"><code>kmeans = KMeans(n_jobs = -1, n_clusters = 4, init=&#39;k-means++&#39;)
kmeans.fit(data_scaled)
pred = kmeans.predict(data_scaled)
rfm_df[&#39;cluster&#39;] = pred
rfm_df.head()</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Recency
</th>
<th>
Frequency
</th>
<th>
Monetary
</th>
<th>
cluster
</th>
</tr>
<tr>
<th>
CustomerID
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
12747.0
</th>
<td>
30
</td>
<td>
17.0
</td>
<td>
613.82
</td>
<td>
1
</td>
</tr>
<tr>
<th>
12748.0
</th>
<td>
6
</td>
<td>
337.0
</td>
<td>
1820.35
</td>
<td>
2
</td>
</tr>
<tr>
<th>
12820.0
</th>
<td>
73
</td>
<td>
11.0
</td>
<td>
170.46
</td>
<td>
0
</td>
</tr>
<tr>
<th>
12823.0
</th>
<td>
1
</td>
<td>
3.0
</td>
<td>
994.50
</td>
<td>
1
</td>
</tr>
<tr>
<th>
12826.0
</th>
<td>
63
</td>
<td>
40.0
</td>
<td>
542.10
</td>
<td>
0
</td>
</tr>
</tbody>
</table>
</div>
<pre class="python"><code>#Cluster number
rfm_df.cluster.value_counts()</code></pre>
<pre><code>

    1    934
    0    568
    2     96
    3      9</code></pre>
<p><b>The cluster value where this decrease in inertia value becomes constant will be chosen as the appropriate cluster value for our data.</b> Looking at the above elbow curve, we can choose between four to six clusters; in other words, we can appropriately group our customer data into four to six customer segments. We will choose to set the number of clusters at five, and now we will proceed to fit the model.</p>
<p>As a note, we must also consider the computation cost when deciding the number of clusters to implement in our data, as computation costs increase with a higher number of clusters.</p>
<pre class="python"><code>#Recency plot
sns.boxplot(rfm_df.cluster,rfm_df.Recency)
plt.title(&#39;Recency&#39;)
plt.show()</code></pre>
<p><img src="rfm_3.png" /></p>
<pre class="python"><code>sns.boxplot(rfm_df.cluster,rfm_df.Frequency)
plt.title(&#39;Frequency&#39;)
plt.show()</code></pre>
<p><img src="rfm_4.png" /></p>
<pre class="python"><code>sns.boxplot(rfm_df.cluster,rfm_df.Monetary)
plt.title(&#39;Monetary&#39;)
plt.show()</code></pre>
<p><img src="rfm_5.png" /></p>
</div>
<div id="final-conclusion" class="section level2">
<h2>Final Conclusion</h2>
<p>The box plots above show that the customers in Cluster 2 and Cluster 3 are the company’s most recent and frequent customers. However, we can see that the customers in these two clusters account for less than 10% of the total number of customers.</p>
<p>This Project provides a brief example of how cluster analysis can enhance the results of RFM analysis. An RFM model can be used in conjunction with certain predictive models, such as k-means clustering, logistic regression, and recommendation to gain even further insight into customer behaviour, which can ultimately elevate a company’s marketing strategy.</p>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<ol style="list-style-type: decimal">
<li>Aditya,A. (2020, March 20). Predictive Segments using RFM Analysis: An In-Depth Guide. Retrieved July 03, 2020, from <a href="https://www.moengage.com/blog/rfm-analysis-using-predictive-segments/" class="uri">https://www.moengage.com/blog/rfm-analysis-using-predictive-segments/</a></li>
<li>Yexi Yuan. (2019, Aug 17). Recency, Frequency, Monetary Model with Python — and how Sephora uses it to optimize their Google and Facebook Ads. Retrieved July 03, 2020, from <a href="https://towardsdatascience.com/recency-frequency-monetary-model-with-python-and-how-sephora-uses-it-to-optimize-their-google-d6a0707c5f17" class="uri">https://towardsdatascience.com/recency-frequency-monetary-model-with-python-and-how-sephora-uses-it-to-optimize-their-google-d6a0707c5f17</a></li>
<li>Campbell, A. (2020, July 05). Customer_segmentation. Lecture presented at EARL 2017 in London, London. <a href="https://earlconf.com/2017/downloads/london/presentations/EARL2017_-_London_-_Alexander_Campbell_-_Customer_segmentation.pdf" class="uri">https://earlconf.com/2017/downloads/london/presentations/EARL2017_-_London_-_Alexander_Campbell_-_Customer_segmentation.pdf</a></li>
<li>Pulkit Sharma (2020, April 23). K Means Clustering: K Means Clustering Algorithm in Python. Retrieved July 14, 2020, from <a href="https://www.analyticsvidhya.com/blog/2019/08/comprehensive-guide-k-means-clustering/" class="uri">https://www.analyticsvidhya.com/blog/2019/08/comprehensive-guide-k-means-clustering/</a></li>
<li>Unknown. (2019, February 12). RFM Analysis. Retrieved July 14, 2020, from <a href="https://www.kaggle.com/yugagrawal95/rfm-analysis" class="uri">https://www.kaggle.com/yugagrawal95/rfm-analysis</a></li>
</ol>
</div>

<div class="footer">
  <p style="text-align: center;">
    <!-- Add icon library -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <a href="https://github.com/Master-of-Business-Analytics" class="fa fa-github fa-2x"></a>
    <br/>
    Created and maintained by the
    <br/>
    <a href="https://www.sauder.ubc.ca/programs/masters-degrees/mban">Master of Business Analytics</a> Community
    <br/>
    Licensed under a
    <br/>
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    <br/>
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
  </p>
</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
